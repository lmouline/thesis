\section[Adaptive systems]{\Glspl{adptSyst}}
\label{sec:back:adapt-syst}

Complexity of nowadays software systems comes with difficulties, errors, and redundant tasks for developers.
These tasks go from installation, configuration to maintenance.
Moreover, they evolve in uncertain and evolving \gls{env}~\cite{DBLP:conf/dagstuhl/EsfahaniM10}.
Following the autonomic computing vision pushed by IBM engineers~\cite{computing2006architectural}, Kephart and Chess put the basis for \glspl{adptSyst}~\cite{DBLP:journals/computer/KephartC03}.
\Glspl{adptSyst} have the capacity to be adapted automatically in response to changes in the \gls{env} or of the system themselves in order to achieve their goals based on high-level objectives.~\cite{DBLP:conf/dagstuhl/ChengLGIMABBBCSDFGGGKKKLMMMPSTTWW09}
If the system performs itself this adaptation mechanism with minimal interference, the literature refers to it as \glspl{sadapt}~\cite{DBLP:conf/dagstuhl/BrunSGGKLMPS09}.

\subsection{Principles and vision}

Danny Weyns	identified two principles for \glspl{adptSyst}~\cite{DBLP:books/sp/19/Weyns19}: the internal and the external principle.
The former one is based on the \textquote{discipline split} defined by Andersson \etal ~\cite{DBLP:conf/icse/AnderssonLMW09}: each \gls{adptSyst} can be split in two concerns.
First, the domain concern categorises the part of the system that deals with the purpose for which the system has been built.
Second, the adaptation concern handles the adaptation mechanism and interacts with the first one without interfering with it~\cite{DBLP:journals/tse/KramerM90}.
On the other hand, the external principle says that \glspl{adptSyst} should handle changes and uncertainties in their environment, the managed systems, and the goal autonomously.

In addition to these principles, the literature has defined four adaptation goals usually called the self-* features~\cite{computing2006architectural}: self-healing, self-optimising, self-configuring, and self-protecting.
First, the healing capacity, defined when the failures in the system can be automatically discovered, diagnosed, and repaired.
Second, the adaptation mechanism can be used to optimise the system by tuning resources and balancing workloads.
Third, the system can be autonomously configured to dynamically adapt to changing \gls{env}.
Four, threats can be anticipated, detected, and identified by the adaptation process to protect the managed system.
In addition, we can add the self-organisation feature~\cite{dempster1998self}: \glspl{adptSyst} can \textquote{acquire and maintain themselves, without external control.}~\cite{DBLP:conf/atal/WolfH04}.
This is mainly discussed for distributed systems, where local rules are applied to adjust their interactions and act cooperatively for adaptation.
However, this mechanism can lead to emergent behaviour~\cite{DBLP:conf/atal/WolfH04}.

Furthermore, \glspl{adptSyst} are composed of four elements: \gls{env}, managed system, adaptation goals, and managing systems~\cite{DBLP:books/sp/19/Weyns19}.
The \gls{env} includes all external entities, virtual or physical, with which the \gls{adptSyst} interacts on each it effects~\cite{DBLP:journals/ansoft/Jackson97}.
Only the elements that are monitored are part of the system.
One may distinguish the environment to the \gls{adptSyst} as, contrary to the element of the \gls{adptSyst}, it cannot be directly impacted by the engineer.
The managed system evolves in the \gls{env} and covers all the part of the system that implements the domain concern.
In the literature, researchers use different names to refer to it: managed element~\cite{DBLP:journals/computer/KephartC03}, system layer~\cite{DBLP:journals/computer/GarlanCHSS04}, core function~\cite{DBLP:journals/taas/SalehieT09}, base-level subsystem~\cite{DBLP:journals/taas/WeynsMA12}, or controllable plant~\cite{DBLP:conf/icse/FilieriHM14}.
To enable the adaptation process, the managed system should contain sensors, for monitoring, and actuators, for modifications.
This adaptation process needs adaptation goals to perform.
They are related to the managed system and mainly concern its software quality metrics~\cite{DBLP:conf/ecsa/WeynsA13}.
At the roots of the self-* features, Kephart and Chess have defined four families of goals: configuration, optimisation, healing, and protection~\cite{DBLP:journals/computer/KephartC03}.  
These goals can evolve over time and should consider the uncertainty of the \gls{env} or the system.
To express such goals, different approaches have been defined such as probabilistic temporal logics~\cite{DBLP:journals/tse/CalinescuGKMT11} or fuzzy goals~\cite{DBLP:conf/re/BaresiPS10}.
Finally, the managing system will use these goals to drive the adaptation of the managed system in response to changes of the \gls{env}.
It thus continuously monitor the \gls{env} and the managing system.
Researchers use different names to refer to this element: autonomic manager~\cite{DBLP:journals/computer/KephartC03}, architecture layer~\cite{DBLP:journals/computer/GarlanCHSS04}, adaptation engine~\cite{DBLP:journals/taas/SalehieT09}, reflective subsystem~\cite{DBLP:journals/taas/WeynsMA12}, controller~\cite{DBLP:conf/icse/FilieriHM14}.

In the litterature, we can find different approaches to engineer \glspl{adptSyst}~\cite{DBLP:journals/computer/GarlanCHSS04}.
Among them, the most used one took its inspiration from control theory~\cite{DBLP:conf/dagstuhl/BrunSGGKLMPS09}: the feedback control loop.
The common implementation is the \gls{mapek} loop~\cite{DBLP:journals/computer/KephartC03, computing2006architectural}.
This loops is split in four phases: monitor, analyse, plan, and execute.
During the monitoring phase, all information of managed element and the \gls{env} are put into the knowledge.
Based on the updated knowledge, the analyse phase detects any need for adaptation using the adaptation goals.
If any, the plan phase computes the set of actions to adjust the managing system structure or behaviour.
Finally, the execute phase completes the plan.

Danny Weyns have identified six waves of engineering \glspl{adptSyst}~\cite{DBLP:books/sp/19/Weyns19}.
First, \textit{automating tasks} that focus on the automation of recurrent and error-prone management tasks of complex systems~\cite{DBLP:journals/computer/KephartC03}.
Second, \textit{architecture-based adaptation} that defines architecture as the basis of supporting engineering of \glspl{adptSyst}. 
Third, \textit{\gls{m@rt}}~\cite{DBLP:journals/computer/BlairBF09, DBLP:journals/computer/MorinBJFS09} that defines a technique to link the \gls{adptSyst} with a model with a \textquote{causal connection}.
Four, \textit{goal-driven adaptation} that put the emphasise on the specification of the system requirements, exposed to uncertainties, and those for the solutions.
Five, \textit{guarantees under uncertainties} that consider uncertainty as a cornerstone concern for \glspl{adptSyst} and that define techniques to guarantee the adaptation goals and the functional correctness of the adaptation components.
Six, \textit{control-based adaptation} that stress the use of the control theory to benefit from a strong mathematical formalism.
Among these six waves, this thesis is part of the third one, \gls{m@rt}, that we detail in the next section.


\subsection[Models@run.time]{\Gls{m@rt}}

- models@run.time: "causally connected self-representation of the associated system that emphasises the structure, behaviour, or goals of the system from a problem space perspective" [7]
    - stucture the infromation received by the SAS
    - causally connection:
        - modification of the system are reflected in the model
        - modification of the model triggers modification of the system
    - abstraction of the system and its goals
    - 4 dimensions that can be used for classification:
        - structural vs behavioural
        - procedural (how: organisation or execution of the system) vs declarative (what: purpose of the adaptation: goal/requirement modeling)
        - functional (functions of the SAS) vs non-functional (quality properties of the SAS)
        - formal vs non-formal
    - \cite{DBLP:journals/computer/MorinBJFS09} defines models@run.time as a set of configuration points, that can be selected at runtime in response to changes

    - model-oriented architecture
        - 3 layers
            - Online Model Space: platform independent layer, manipulates model
            - Causal Connection: platform-specific, "drivers", link between the 2 layers: model and runtime spaces
            - Business Application: contains application logic, is equipped with sensors that track runtime events, equipped with sensors and "factories services" (actuators)
        - 4 types of runtime models
            - feature model, describes the configuration/variability point
            - context model, specifies relevant variables of the environment
            - reasoning model, associates features with particular context, example: Event-Condition-Action rules
            - architecture model, specifies the component composition of the application
        - 5 elements
            - Event processor (implement the Monitor stage): update the context model with the received information
            - Goal-Based Reasoner (implements the Analyse stage): uses the feature and reasoning model to select the new features that should be executed by the SAS, according to goals
            - Model Weaver (implements part of the Plan stage): from the selected feature, compose a new architecture model
            - Configuration checker (implements part of the Plan stage): check the configuration at runtime
            - Configuration manager (implements part of the Plan stage + the Execute stage): define the right sequence of actions to reach the proposed architecture model, execute them 

Sum-up:
    - causally connection between the the DAS and the model: model represents the up-to date state of the system, modification on the model will trigger modification on the system
    - models allow to tame the complexity and the huge amount of information
    - with goal first class citizen, models enable anaysis of the behaviour of SAS at runtime, supporting decision making
    - 4 dimensions of runtime models: structural or behavioural, procedural or declarative, functional or non-functional, formal or non-formal
    - SAS can be viewed as a set of possible configuration that should be selected/modified at runtime 

\subsection{Context}

\subsection[Adaptive systems in the context of this thesis]{\Glspl{adptSyst} in this thesis}

- following the \gls{mapek} loop, the adaptation is based on a shared knowledge
- this knowledge is uncertain and time related
- in this thesis, we propose a meta-model to represent decisions over time, following the \gls{m@rt} paradigm
- a language to handle uncertainty