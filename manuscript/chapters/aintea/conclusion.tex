\section{Conclusion, limitation and future works}
\label{sec:conclusion}

Data are inherently uncertain.
This uncertainty can modify the understanding of the elements represented by these data.
Furthermore, it may damage the decision made upon this knowledge.
Managing this uncertainty calls for a strong understanding of probability theory.
However, it can be far from developers expertize.
In order to help them manipulating this uncertainty, we define \languageName{}, a language which integrates concepts related to data uncertainty.
Mainly, we define uncertain data types and we map uncertainty propagation to arithmetic, boolean, and comparison operators.
In addition, we define operators specific to the manipulation of the uncertainty representation.
In our validation, we show that our language is as concise as state-of-the-art solutions.
Contrary to these solutions, we also show that our solution can detect errors earlier.
Thanks to the semantics, which supports uncertainty, errors message help developers in their development of algorithms that use uncertain data.

%Below, we list the limitations of our approach that call for further research.
%Our approach has some limitations that call for further research.
%It does not consider:
%\begin{itemize}
%    \vspace{-0.5em}
%    \setlength\itemsep{-0.3em}
%    \item all the different kinds of uncertainty,
%    \item all data structures,
%    \item all the different places where uncertainty is propagated.
%\end{itemize}

%\paragraph{Different kinds of uncertainty}
Our current work addresses only uncertainty on values.
However, other kinds of uncertainties exist such as uncertainty of existence or temporal uncertainty (loss of confidence over time).
%The first one corresponds to the confidence that a value exists or not.
%It can result from faulty data sources that send wrong data.
%The second one can be used to represent the loss of confidence in value over time.
%\paragraph{No complex data types}
In this work, we focus our studies on the primitive data types (numeric and boolean) and references (1:1 relation).
However, it exists several other data structures, from the simplest ones like arrays to complex ones like graphs or trees.
%While they are useful to build algorithms to reason over data, they come with new challenges.
%For example: what is an uncertain sorted collection? While an element is added, how the uncertainty is shared among the previous and the new elements? etc.
%\paragraph{Propagation of uncertainty}
In our language, we map the uncertainty propagation to operators.
%We did not study the impact of control flow statements on the uncertainty propagation.
Introducing uncertainty as a first-class citizen will inevitably modify current behavior of control flow statements such as \textit{IF}-conditions.
We strongly think that this new data type in the type system will lead to further research directions.
%However, we identify two other situations that should be considered, with their challenges.
%First, the propagation through control flow statements: how the uncertainty is propagated after an \textit{IF}-condition, a \textit{FOR}-loop and a \textit{WHILE}-loop.
%Second, the propagation from one kind of uncertainty to another one.
%For example, how the uncertainty of presence should be propagated to the uncertainty of a sum, average or variance computation?

%\subsection{Future Work}
%\label{sec:futureWork}
%
%\begin{itemize}
%	\item Other uncertainty representation
%	\item More complex data structure (array, classes/structure, ...)
%	\item Different control flow
%	\item Support for complex probability distributions
%\end{itemize}
%
%\warning{Ludo}{Below, you will some copy/paste from previous section. The text is not well structured and proofread. But it gives some idea to write the future work section ;)}
%
%From previous uncertain boolean section:
%A future work will be to investigate simulation techniques to be able to resolve the last case when it occurs.
%However, we claim that it should appear rarely.
%To be dependent and non-disjoint, both values need to be defined upon an identical variable and have an overlap between the possible values.
%Taking our example, let a boolean $b_3$ equal to $t \geqslant 0$.
%$b_3$ is dependent and non-disjoint with $b_1$ (equals $t > 18$).
%Applying the \andOp{} operator between both variable is equivalent to check if $t$ greater than 18, \ie to check if $b_1$ is true.
%Computing the result of the \orOp{} operator is equivalent to read the value of the $b_3$ value.
%More generally, our intuition is that usual operator between two dependent and non-disjoint booleans will be naturally simplified by developers with disjoint booleans.
%
% Control flow work
%Conditional expressions, which have boolean type, modify the control flow by forking it.
%As uncertain booleans have similar semantic to certain ones, the question that we wonder was: should we allow conditional expressions with uncertain boolean type?
%
%With certain one, the expression is evaluated at runtime and one branch is selected according to the result.
%With uncertain ones, the executor cannot decide which branch to execute.
%We thus identified two possible controls flows: the classical one and the uncertain one.
%
%For the classical one, an implicit operation should be performed to get a certain one.
%However, it can be done using at least two strategies.
%First, a random selection can be made using the draw operator.
%It is specially used in the probability programming domain.
%By executing several times the same piece of code, it allows inferring the distribution of the result without propagating the uncertainty by applying the probability formula.
%Second, a cast can be done using the cast or confidence operator.
%This allows going to a certain world.
%
%For the uncertain execution, as the executor cannot decide which branch should be executed, it should execute all of them and propagate the uncertainty throw the execution.
%For example, let us imagine the following code:
%
%\begin{lstlisting}[style=javaStyle, caption=Example for uncertain control flow, label=lst:ucf-bool-example]
%uncertain_bool b = (TRUE, 0.4)
%uncertain_int n;
%if(uncertain_bool)
% n = (5, 0.8)
%else
% n = (-5, 0.8)
%\end{lstlisting}
%
%As \textit{b} is true with a confidence of 40\%, n should be equal to 5 with a confidence of (40\% * 80\% = 32\%) and to -5 with a confidence of (60\% * 80\% = 48\%) (considering b and n independent).
%
%These three execution semantics come with several questions.
%For the classical one: how to combine different execution semantic? what are the impact on performances?
%For the other one: should the execution be parallel or not? how to ensure that the execution do not have side effect(s)? what are the impact on the performance?
%
%As we focus on integrating uncertainty propagation to data type, we decide to let all these questions for future research.
%Plus, we do not want to choose an arbitrary default semantic.
%We thus forbid the usage of uncertain boolean as condition of \textit{IF} and \textit{WHILE} expression.
%We thus cannot allow implicit conversion in our language.
%Developers must then dismiss the uncertainty using the uncertainty operators.

